#ifndef _SDD_ORDER_ORDER_HH_
#define _SDD_ORDER_ORDER_HH_

#include <memory>

#include "sdd/conf/variable_traits.hh"

namespace sdd { namespace order {

/// @cond INTERNAL_DOC

/*-------------------------------------------------------------------------------------------*/

// Forward declaration of an order's node.
template <typename C>
struct node;

/*-------------------------------------------------------------------------------------------*/

/// @brief Represent an order of identifiers.
template <typename C>
using order_ptr_type = std::shared_ptr<node<C>>;

/*-------------------------------------------------------------------------------------------*/

/// @brief An element of a linked list of nodes, associating a (library) variable to an (user)
/// identifier.
///
/// We create our own type rather than using std::list. This is beacause we don't want the user
/// to add identifier to an order which has already been added as a nested order.
template <typename C>
struct node
{
  /// @brief A variable type.
  typedef typename C::Variable variable_type;

  /// @brief An identifier type.
  typedef typename C::Identifier identifier_type;

  /// @brief The library variable.
  ///
  /// A variable is automatically assigned to an identifier by the library.
  const variable_type variable_;

  /// @brief The user identifier.
  ///
  /// When nullptr, it's an artificial node. That is, a node generated by the library.
  const std::unique_ptr<identifier_type> identifier_;

  /// @brief The nested order.
  ///
  /// If empty, the node is a flat node.
  const order_ptr_type<C> nested_;

  /// @brief The node's next variable.
  const order_ptr_type<C> next_;

  /// @brief Constructor.
  node( const variable_type& var, std::unique_ptr<identifier_type>&& id
      , order_ptr_type<C> nested, order_ptr_type<C> next)
    : variable_(var)
    , identifier_(std::move(id))
    , nested_(nested)
    , next_(next)
  {
  }
};

/// @endcond

/*-------------------------------------------------------------------------------------------*/

/// @brief Represent an order of identifiers.
template <typename C>
class order
{
public:

  /// @brief The type of a variable.
  typedef typename C::Variable variable_type;

  /// @brief The type of an identifier.
  typedef typename C::Identifier identifier_type;

/// @cond INTERNAL_DOC
private:

  /// @brief The concrete order.
  order_ptr_type<C> order_ptr;

public:

  /// @brief Constructor.
  order(const order_ptr_type<C>& ptr)
    : order_ptr(ptr)
  {
  }

  /// @brief Get the concrete order.
  const order_ptr_type<C>&
  ptr()
  const noexcept
  {
    return order_ptr;
  }

/// @endcond

  order&
  operator=(const order& other)
  {
    order_ptr = other.order_ptr;
    return *this;
  }

  /// @brief Tell if this order is empty.
  ///
  /// It's unsafe to call any other method if this order is empty.
  bool
  empty()
  const noexcept
  {
    return not order_ptr;
  }

  /// @brief Get the variable of this order's head.
  const variable_type&
  variable()
  const noexcept
  {
    return order_ptr->variable_;
  }

  /// @brief Get the idetifier of this order's head.
  const identifier_type&
  identifier()
  const noexcept
  {
    return *order_ptr->identifier_;
  }

  /// @brief Get this order's head's next order.
  order
  next()
  const noexcept
  {
    return order(order_ptr->next_);
  }

  /// @brief Get this order's head's nested order.
  order
  nested()
  const noexcept
  {
    return order(order_ptr->nested_);
  }

  /// @brief Get the variable of an identifier
  const variable_type&
  identifier_variable(const identifier_type& id)
  const
  {
    return variable_type();
  }
};

/*-------------------------------------------------------------------------------------------*/

/// @brief Return an empty order to be augmented with add_identifier.
template <typename C>
order<C>
empty_order()
{
  return order<C>(nullptr);
}

/*-------------------------------------------------------------------------------------------*/

/// @brief Add a flat identifier to an order.
template <typename C>
order<C>
add_identifier(const typename C::Identifier& id, const order<C>& o)
{
  typedef typename C::Variable variable_type;
  typedef typename C::Identifier id_type;
  typedef std::unique_ptr<id_type> optional_id_type;

  const variable_type var = not o.empty()
                          ? conf::variable_traits<variable_type>::next(o.variable())
                          : conf::variable_traits<variable_type>::first();

  return order<C>(std::make_shared<node<C>>( var
                                           , optional_id_type(new id_type(id))
                                           , nullptr
                                           , o.ptr()));
}

/*-------------------------------------------------------------------------------------------*/

/// @brief Add an hierarchical identifier to an order.
template <typename C>
order<C>
add_identifier(const typename C::Identifier& id, const order<C>& o, const order<C>& nested_o)
{
  if (nested_o.empty())
  {
    return add_identifier(id, o);
  }

  typedef typename C::Variable variable_type;
  typedef typename C::Identifier id_type;
  typedef std::unique_ptr<id_type> optional_id_type;

  const variable_type var = not o.empty()
                          ? conf::variable_traits<variable_type>::next(o.variable())
                          : conf::variable_traits<variable_type>::first();

  return order<C>(std::make_shared<node<C>>( var
                                           , optional_id_type(new id_type(id))
                                           , nested_o.ptr()
                                           , o.ptr()));
}

/*-------------------------------------------------------------------------------------------*/

}} // namespace sdd::order

#endif // _SDD_ORDER_ORDER_HH_
