#ifndef _SDD_ORDER_ORDER_HH_
#define _SDD_ORDER_ORDER_HH_

#include <algorithm> // find
#include <initializer_list>
#include <iostream>
#include <memory>    // shared_ptr, unique_ptr
#include <sstream>
#include <utility>   // pair
#include <vector>

#include "sdd/order/order_builder.hh"
#include "sdd/util/boost_multiindex_no_warnings.hh"
#include "sdd/util/hash.hh"

namespace sdd {

namespace bmi = boost::multi_index;

/*------------------------------------------------------------------------------------------------*/

/// @brief Represent an order of identifiers, possibly with some hierarchy.
///
/// It helps associate a variable (generated by the library) in an SDD to an identifiers
/// (provided to the user). An identifier should appear only once by order.
template <typename C>
class order final
{
public:

  /// @brief A user's identifier type.
  using identifier_type = typename C::Identifier;

  /// @brief A library's variable type.
  using variable_type = typename C::Variable;

  /// @internal
  /// @brief The position of a node, unique to it.
  using position_type = unsigned int;

private:

  /// @brief A path, following hierarchies, to a node.
  using path_type = std::vector<identifier_type>;

  /// @brief A node in an order.
  ///
  /// An order is actually represented as a linked list of node.
  struct node
  {
    /// @brief The (user's) identifier of this node.
    const identifier_type identifier;

    /// @brief The (library's) variable of this node.
    const variable_type variable;

    /// @brief Absolute position, when seeing the order as flatten.
    ///
    /// Used to establish a total order on identifiers.
    const position_type position;

    /// @brief A pointer to following order's head.
    const node* next;

    /// @brief A pointer to the nested order's head.
    const node* nested;

    /// @brief The path to this node.
    const std::shared_ptr<path_type> path_ptr;

    /// @brief Constructor.
    node( const identifier_type& id, const variable_type& var, unsigned int pos
        , const node* nxt, const node* nst
        , const std::shared_ptr<path_type>& path)
      : identifier(id)
      , variable(var)
      , position(pos)
      , next(nxt)
      , nested(nst)
      , path_ptr(path)
    {}

    /// @brief Compare two node using their abolute position.
    bool
    operator<(const node& other)
    const noexcept
    {
      return position < other.position;
    }
  }; // struct node

  struct compare_node
  {
    bool
    operator()(const node& lhs, position_type rhs)
    const noexcept
    {
      return lhs.position < rhs;
    }

    bool
    operator()(position_type lhs, const node& rhs)
    const noexcept
    {
      return lhs < rhs.position;
    }
  };

  /// @brief Tag to access nodes using their absolute positions.
  struct by_position {};

  /// @brief Tag to access nodes using their identifiers.
  struct by_identifier {};

  /// @brief The type of the container of nodes.
  ///
  /// A boost::multi_index::multi_index_container is used in order to be able to access nodes
  /// using different criterions.
  typedef bmi::multi_index_container
          < node
          , bmi::indexed_by
            < // sort by node::operator<
              bmi::ordered_unique< bmi::tag<by_position>
                                 , bmi::identity<node>
                                 >

              // retrieve using identifier's hash
            , bmi::hashed_unique< bmi::tag<by_identifier>
                                , bmi::member<node, const identifier_type, &node::identifier>
                                , std::hash<identifier_type>
                                >
            >
          > nodes_type;

  /// @brief The concrete order.
  const std::shared_ptr<nodes_type> nodes_ptr_;

  /// @brief The first node in the order.
  const node* head_;

public:

  /// @brief Constructor.
  order(const order_builder<C>& builder)
    : nodes_ptr_(mk_nodes_ptr(builder))
    , head_(mk_head())
  {}

  /// @brief Tell if upper contains nested in its possibly contained hierarchy.
  /// @param uppper Must belong to the current order.
  /// @param nested Must belong to the current order.
  bool
  contains(position_type upper, position_type nested)
  const noexcept
  {
    const auto& identifiers = nodes_ptr_->template get<by_position>();
    const auto search_nested = identifiers.find(nested, compare_node());
    const auto search_uppper = identifiers.find(upper, compare_node());
    const auto& path = *search_nested->path_ptr;
    return std::find(path.begin(), path.end(), search_uppper->identifier) != path.end();
  }

  /// @brief
  const typename nodes_type::template index<by_identifier>::type&
  identifiers()
  const noexcept
  {
    return nodes_ptr_->template get<by_identifier>();
  }

  /// @brief Get the variable of this order's head.
  const variable_type&
  variable()
  const noexcept
  {
    return head_->variable;
  }

  /// @brief Get the identifier of this order's head.
  const identifier_type&
  identifier()
  const noexcept
  {
    return head_->identifier;
  }

  /// @brief Get the position of this order's head.
  position_type
  position()
  const noexcept
  {
    return head_->position;
  }

  /// @brief Get the next order of this order's head.
  order
  next()
  const noexcept
  {
    return order(nodes_ptr_, head_->next);
  }

  /// @brief Get the nested order of this order's head.
  order
  nested()
  const noexcept
  {
    return order(nodes_ptr_, head_->nested);
  }

  /// @brief Tell if this order is empty.
  bool
  empty()
  const noexcept
  {
    return head_ == nullptr;
  }

  /// @internal
  position_type
  identifier_position(const identifier_type& id)
  const noexcept
  {
    return (nodes_ptr_->template get<by_identifier>().find(id))->position;
  }

  /// @internal
  std::size_t
  hash()
  const noexcept
  {
    std::size_t seed = 0;
    util::hash_combine(seed, nodes_ptr_.get());
    util::hash_combine(seed, head_);
    return seed;
  }

  /// @internal
  bool
  operator==(const order& other)
  const noexcept
  {
    return nodes_ptr_ == other.nodes_ptr_ and head_ == other.head_;
  }

private:

  /// @brief Construct whith a shallow copy an already existing order.
  order(const std::shared_ptr<nodes_type>& ptr, const node* head)
    : nodes_ptr_(ptr)
    , head_(head)
  {}

  /// @brief Create the concrete order using an order_builder.
  static
  std::shared_ptr<nodes_type>
  mk_nodes_ptr(const order_builder<C>& builder)
  {
    std::shared_ptr<nodes_type> nodes_ptr = std::make_shared<nodes_type>();

    if (builder.empty())
    {
      return nodes_ptr;
    }

    unsigned int pos = 0;

    // To enable recursion in the lambda.
    std::function<
      std::pair<const node*, variable_type>
      (const order_builder<C>&, const std::shared_ptr<path_type>&)
    > helper;

    helper = [&helper, &nodes_ptr, &pos]
    (const order_builder<C>& ob, const std::shared_ptr<path_type>& path)
    -> std::pair<const node*, unsigned int>
    {
      constexpr variable_type first_variable = 0;

      const unsigned int current_position = pos++;

      std::pair<const node*, variable_type> nested(nullptr, first_variable);
      std::pair<const node*, variable_type> next(nullptr, first_variable);

      if (not ob.nested().empty())
      {
        const auto new_path = std::make_shared<path_type>(*path);
        new_path->push_back(ob.identifier());
        new_path->shrink_to_fit();
        nested = helper(ob.nested(), new_path);
      }

      if (not ob.next().empty())
      {
        next = helper(ob.next(), path);
      }

      const auto& variable = next.second;
      /// TODO Manage artificial identifiers.
      const node n(ob.identifier(), variable, current_position, next.first, nested.first, path);

      const auto insertion = nodes_ptr->insert(n);
      if (not insertion.second)
      {
        std::stringstream ss;
        ss << "Duplicate identifier " << ob.identifier();
        throw std::runtime_error(ss.str());
      }
      return std::make_pair(&*(insertion.first), variable + 1);
    };

    helper(builder, std::make_shared<path_type>());

    return nodes_ptr;
  }

  /// @brief Get the first node in the order.
  const node*
  mk_head()
  const noexcept
  {
    const auto& positions = nodes_ptr_->template get<by_position>();
    const auto begin = positions.begin();
    return begin == positions.end() ? nullptr : &*begin;
  }
};

/*------------------------------------------------------------------------------------------------*/

/// @brief Textual representation of an order.
/// @related order
template <typename C>
std::ostream&
operator<<(std::ostream& os, const order<C>& ord)
{
  const std::function<std::ostream&(const order<C>&, unsigned int)> helper
   = [&helper, &os](const order<C>& o, unsigned int indent)
  -> std::ostream&
  {
    if (not o.empty())
    {
      const std::string spaces(indent, ' ');
      os << spaces << o.identifier() << std::endl;
      if (not o.nested().empty())
      {
        helper(o.nested(), indent + 2);
      }
      if (not o.next().empty())
      {
        helper(o.next(), indent);
      }
    }
    return os;
  };
  return helper(ord, 0);
}

/*------------------------------------------------------------------------------------------------*/

} // namespace sdd

namespace std {

/*------------------------------------------------------------------------------------------------*/

/// @internal
/// @brief Hash specialization for sdd::order.
template <typename C>
struct hash<sdd::order<C>>
{
  std::size_t
  operator()(const sdd::order<C>& o)
  const noexcept
  {
    return o.hash();
  }
};

/*------------------------------------------------------------------------------------------------*/

} // namespace std

#endif // _SDD_ORDER_ORDER_HH_
