#ifndef _SDD_ORDER_ORDER_HH_
#define _SDD_ORDER_ORDER_HH_

#include <memory>

#include "sdd/conf/variable_traits.hh"

namespace sdd { namespace order {

/*-------------------------------------------------------------------------------------------*/

/// @cond INTERNAL_DOC

/// @brief An element of a linked list of nodes, associating a (library) variable to an (user)
/// identifier.
///
/// We create our own type rather than using std::list. This is beacause we don't want the user
/// to add identifier to an order which has already been added as a nested order.
template <typename C>
struct node
{
  /// @brief A variable type.
  typedef typename C::Variable variable_type;

  /// @brief An identifier type.
  typedef typename C::Identifier identifier_type;

  /// @brief The library variable.
  ///
  /// A variable is automatically assigned to an identifier by the library.
  const variable_type variable_;

  /// @brief The user identifier.
  ///
  /// When nullptr, it's an artificial node. That is, a node generated by the library.
  const std::unique_ptr<identifier_type> identifier_;

  /// @brief The nested order.
  ///
  /// If nullptr, the node is a flat node.
  const std::shared_ptr<node<C>> nested_;

  /// @brief The node's next variable.
  const std::shared_ptr<node<C>> next_;

  /// @brief Constructor.
  node( const variable_type& var, std::unique_ptr<identifier_type>&& id
      , std::shared_ptr<node> nested, std::shared_ptr<node> next)
    : variable_(var)
    , identifier_(std::move(id))
    , nested_(nested)
    , next_(next)
  {
  }
};

/// @endcond

/*-------------------------------------------------------------------------------------------*/

/// @brief Represent an order of identifiers.
template <typename C>
using order = std::shared_ptr<node<C>>;

/*-------------------------------------------------------------------------------------------*/

/// @brief Return an empty order to be augmented with add_identifier.
template <typename C>
order<C>
empty_order()
{
  return nullptr;
}

/*-------------------------------------------------------------------------------------------*/

/// @brief Add a flat identifier to an order.
template <typename C>
order<C>
add_identifier(const typename C::Identifier& id, const order<C>& o)
{
  typedef typename C::Variable variable_type;
  typedef typename C::Identifier id_type;
  typedef std::unique_ptr<id_type> optional_id_type;
  const variable_type var = o // empty order or not?
                          ? conf::variable_traits<variable_type>::next(o->variable_)
                          : conf::variable_traits<variable_type>::first();
  return order<C>(new node<C>(var, optional_id_type(new id_type(id)), nullptr, o));
}

/*-------------------------------------------------------------------------------------------*/

/// @brief Add an hierarchical identifier to an order.
template <typename C>
order<C>
add_identifier(const typename C::Identifier& id, const order<C>& o, const order<C>& nested_o)
{
  if (not nested_o)
  {
    return add_identifier(id, o);
  }

  typedef typename C::Variable variable_type;
  typedef typename C::Identifier id_type;
  typedef std::unique_ptr<id_type> optional_id_type;
  const variable_type var = o // empty order or not?
                          ? conf::variable_traits<variable_type>::next(o->variable_)
                          : conf::variable_traits<variable_type>::first();
  return order<C>(new node<C>(var, optional_id_type(new id_type(id)), nested_o, o));
}

/*-------------------------------------------------------------------------------------------*/

}} // namespace sdd::order

#endif // _SDD_ORDER_ORDER_HH_
