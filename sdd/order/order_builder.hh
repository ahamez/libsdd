#ifndef _SDD_ORDER_ORDER_BUILDER_HH_
#define _SDD_ORDER_ORDER_BUILDER_HH_

#include <initializer_list>
#include <memory>    // shared_ptr, unique_ptr
#include <vector>

namespace sdd {

/*------------------------------------------------------------------------------------------------*/

/// @brief Prepare an order to build.
template <typename C>
class order_builder final
{
public:

  /// @brief The type of a variable.
  typedef typename C::Variable variable_type;

  /// @brief The type of an identifier.
  typedef typename C::Identifier identifier_type;

private:

  // Pre-declaration of a node.
  struct node;

  /// @brief The type of a pointer to a node.
  ///
  /// It's the actual reprensation of an order to build
  typedef std::shared_ptr<node> node_ptr;

  /// @brief The building block of an order_builder.
  struct node
  {
    /// @brief The user identifier.
    ///
    /// When nullptr, it's an artificial node. That is, a node generated by the library.
    const std::unique_ptr<identifier_type> identifier;

    /// @brief The nested order.
    ///
    /// If nullptr, this node is a flat node.
    const node_ptr nested;

    /// @brief The node's next variable.
    ///
    /// If nullptr, this node is the last one.
    const node_ptr next;

    /// @brief Constructor.
    node(std::unique_ptr<identifier_type>&& id, const node_ptr& nst, const node_ptr& nxt)
      : identifier(std::move(id))
      , nested(nst)
      , next(nxt)
    {
    }
  };

  /// @brief The concrete order.
  node_ptr order_ptr_;

public:

  /// @brief Default constructor.
  order_builder()
    : order_ptr_(nullptr)
  {
  }

  /// @brief Constructor from a list of identifiers.
  template <typename InputIterator>
  order_builder(InputIterator begin, InputIterator end)
    : order_builder()
  {
    std::vector<identifier_type> tmp(begin, end);
    for (auto rcit = tmp.crbegin(); rcit != tmp.crend(); ++rcit)
    {
      add(*rcit);
    }
  }

  /// @brief Constructor from a list of identifiers.
  order_builder(std::initializer_list<identifier_type> list)
    : order_builder(list.begin(), list.end())
  {
  }

  /// @brief Tell if this order is empty.
  ///
  /// It's unsafe to call any other method, except add(), if this order is empty.
  bool
  empty()
  const noexcept
  {
    return not order_ptr_;
  }

  /// @brief Get the idetifier of this order's head.
  const identifier_type&
  identifier()
  const noexcept
  {
    return *order_ptr_->identifier;
  }

  /// @brief Get this order's head's next order.
  order_builder
  next()
  const noexcept
  {
    return order_builder(order_ptr_->next);
  }

  /// @brief Get this order's head's nested order.
  order_builder
  nested()
  const noexcept
  {
    return order_builder(order_ptr_->nested);
  }

  /// @brief Add a flat identifier at the top of this order.
  order_builder&
  add(const identifier_type& id)
  {
    return add(id, nullptr);
  }

  /// @brief Add a nested identifier at the top of this order.
  ///
  /// If nested is an empty order, a flat identifier is added instead.
  order_builder&
  add(const identifier_type& id, const order_builder& nested)
  {
    return add(id, nested.order_ptr_);
  }

  /// @brief Concatenate an order at the end of this one.
  void
  concat(const order_builder& next)
  {
    node_ptr current = order_ptr_;
    while (current->next)
    {
      current = current->next;
    }
    current->next = next.order_ptr_;
  }

private:

  /// @brief Constructor from an already existing pointer.
  order_builder(const node_ptr& ptr)
    : order_ptr_(ptr)
  {
  }

  /// @brief Actual implementation of add.
  order_builder&
  add(const identifier_type& id, const node_ptr& nested_ptr)
  {
    typedef std::unique_ptr<identifier_type> optional_id_type;

    order_ptr_ = std::make_shared<node>( optional_id_type(new identifier_type(id))
                                       , nested_ptr
                                       , order_ptr_);
    return *this;
  }
};

/*------------------------------------------------------------------------------------------------*/


} // namespace sdd

#endif // _SDD_ORDER_ORDER_BUILDER_HH_
