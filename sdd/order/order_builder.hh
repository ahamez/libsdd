#ifndef _SDD_ORDER_ORDER_BUILDER_HH_
#define _SDD_ORDER_ORDER_BUILDER_HH_

#include <initializer_list>
#include <memory>    // shared_ptr, unique_ptr
#include <vector>

namespace sdd {

/*------------------------------------------------------------------------------------------------*/

/// @brief Prepare an order to build.
template <typename C>
class order_builder final
{
public:

  /// @brief The type of a variable.
  typedef typename C::Variable variable_type;

  /// @brief The type of an identifier.
  typedef typename C::Identifier identifier_type;

private:

  // Pre-declaration of a node.
  struct node;

  /// @brief The type of a pointer to a node.
  ///
  /// It's the actual reprensation of an order to build
  using node_ptr = std::shared_ptr<node>;

  /// @brief The building block of an order_builder.
  struct node
  {
    /// @brief The user identifier.
    ///
    /// When nullptr, it's an artificial node. That is, a node generated by the library.
    const identifier_type identifier;

    /// @brief The nested order.
    ///
    /// If nullptr, this node is a flat node.
    const node_ptr nested;

    /// @brief The node's next variable.
    ///
    /// If nullptr, this node is the last one.
    const node_ptr next;

    /// @brief Constructor.
    node(const identifier_type& id, const node_ptr& nst, const node_ptr& nxt)
      : identifier(id)
      , nested(nst)
      , next(nxt)
    {}
  };

  /// @brief The concrete order.
  node_ptr ptr_;

public:

  /// @brief Default constructor.
  order_builder()
    : ptr_(nullptr)
  {}

  /// @brief Constructor from a list of identifiers.
  template <typename InputIterator>
  order_builder(InputIterator begin, InputIterator end)
    : order_builder()
  {
    std::vector<identifier_type> tmp(begin, end);
    for (auto rcit = tmp.crbegin(); rcit != tmp.crend(); ++rcit)
    {
      push(*rcit, nullptr);
    }
  }

  /// @brief Constructor from a list of identifiers.
  order_builder(std::initializer_list<identifier_type> list)
    : order_builder(list.begin(), list.end())
  {}

  /// @brief Constructor with a single identifier.
  order_builder(identifier_type&& id)
    : ptr_(mk_ptr(id, nullptr, nullptr))
  {}

  /// @brief Constructor with an identifier and its associated nested order.
  order_builder(identifier_type&& id, const order_builder& nested)
    : ptr_(mk_ptr(id, nested.ptr_, nullptr))
  {}

  /// @brief Tell if this order is empty.
  ///
  /// It's unsafe to call any other method, except push(), if this order is empty.
  bool
  empty()
  const noexcept
  {
    return not ptr_;
  }

  /// @brief Get the identifier of this order's head.
  const identifier_type&
  identifier()
  const noexcept
  {
    return ptr_->identifier;
  }

  /// @brief Get this order's head's next order.
  order_builder
  next()
  const noexcept
  {
    return order_builder(ptr_->next);
  }

  /// @brief Get this order's head's nested order.
  order_builder
  nested()
  const noexcept
  {
    return order_builder(ptr_->nested);
  }

  /// @internal
  /// @brief Push a flat identifier at the top of this order.
  order_builder&
  push(const identifier_type& id)
  {
    return push(id, nullptr);
  }

  /// @internal
  /// @brief Add a nested identifier at the top of this order.
  ///
  /// If nested is an empty order, a flat identifier is added instead.
  order_builder&
  push(const identifier_type& id, const order_builder& nested)
  {
    return push(id, nested.ptr_);
  }

  /// @brief Concatenate this order with another one.
  ///
  /// Returns a copy.
  order_builder
  operator<<(const order_builder& next)
  const&
  {
    return order_builder(concat(ptr_, next.ptr_));
  }

  /// @brief Concatenate this order with another one.
  order_builder
  operator<<(const order_builder& next)
  &&
  {
    ptr_ = concat(ptr_, next.ptr_);
    return *this;
  }

private:

  /// @brief Concatenate two order builders.
  static
  node_ptr
  concat(node_ptr head, node_ptr next)
  {
    return head
         ? std::make_shared<node>(head->identifier, head->nested, concat(head->next, next))
         : next;
  }

  /// @brief Constructor from an already existing pointer.
  order_builder(const node_ptr& ptr)
    : ptr_(ptr)
  {}

  /// @brief Actual implementation of push.
  order_builder&
  push(const identifier_type& id, const node_ptr& nested_ptr)
  {
    ptr_ = std::make_shared<node>(id, nested_ptr, ptr_);
    return *this;
  }

  static
  node_ptr
  mk_ptr(const identifier_type& id, const node_ptr& nested_ptr, const node_ptr& next_ptr)
  {
    return std::make_shared<node>(id, nested_ptr, next_ptr);
  }
};

/*------------------------------------------------------------------------------------------------*/

} // namespace sdd

#endif // _SDD_ORDER_ORDER_BUILDER_HH_
